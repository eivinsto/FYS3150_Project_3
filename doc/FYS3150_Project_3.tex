\documentclass[reprint,english,notitlepage]{revtex4-1}  % defines the basic parameters of the document

% if you want a single-column, remove reprint

% allows special characters (including æøå)
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

%% note that you may need to download some of these packages manually, it depends on your setup.
%% I recommend downloading TeXMaker, because it includes a large library of the most common packages.

\usepackage{physics,amssymb}  % mathematical symbols (physics imports amsmath)
\usepackage{graphicx}         % include graphics such as plots
\usepackage{xcolor}           % set colors
\usepackage{hyperref}         % automagic cross-referencing (this is GODLIKE)
\usepackage{tikz}             % draw figures manually
\usepackage{listings}         % display code
\usepackage{subfigure}        % imports a lot of cool and useful figure commands
\usepackage{cprotect}
\usepackage{float}

% defines the color of hyperref objects
% Blending two colors:  blue!80!black  =  80% blue and 20% black
\hypersetup{ % this is just my personal choice, feel free to change things
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}}

%% Defines the style of the programming listing
%% This is actually my personal template, go ahead and change stuff if you want
\lstnewenvironment{python}{
	\lstset{ %
		inputpath=,
		backgroundcolor=\color{white!88!black},
		basicstyle={\ttfamily\scriptsize},
		commentstyle=\color{magenta},
		language=Python,
		morekeywords={True,False},
		tabsize=4,
		stringstyle=\color{green!55!black},
		frame=single,
		keywordstyle=\color{blue},
		showstringspaces=false,
		columns=fullflexible,
		keepspaces=true}
}{}

\lstnewenvironment{cpp}{
	\lstset{ %
		inputpath=,
		backgroundcolor=\color{white!88!black},
		basicstyle={\ttfamily\scriptsize},
		commentstyle=\color{magenta},
		language=C++,
		morekeywords={True,False},
		tabsize=4,
		stringstyle=\color{green!55!black},
		frame=single,
		keywordstyle=\color{blue},
		showstringspaces=false,
		columns=fullflexible,
		keepspaces=true}
}{}

\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}



\usepackage{thmtools}
\DeclareMathOperator{\nullspace}{Nul}
\DeclareMathOperator{\collspace}{Col}
\DeclareMathOperator{\rref}{Rref}
%%\DeclareMathOperator{\dim}{Dim}

 % "meq": must be equal
\newcommand{\meq}{\overset{!}{=}}
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}

\newcommand{\R}{\mathbb{R}}
\newcommand*\Heq{\ensuremath{\overset{\kern2pt L'H}{=}}}
\usepackage{bm}
\newcommand{\uveci}{{\bm{\hat{\textnormal{\bfseries\i}}}}}
\newcommand{\uvecj}{{\bm{\hat{\textnormal{\bfseries\j}}}}}
\DeclareRobustCommand{\uvec}[1]{{%
  \ifcsname uvec#1\endcsname
     \csname uvec#1\endcsname
   \else
    \bm{\hat{\mathbf{#1}}}%
   \fi
}}
\usepackage[binary-units=true]{siunitx}

\makeatletter
\newcommand*{\balancecolsandclearpage}{%
  \close@column@grid
  \cleardoublepage
  \twocolumngrid
}
\makeatother

\newcounter{subproject}
\renewcommand{\thesubproject}{\alph{subproject}}
\newenvironment{subproj}{
\begin{description}
	\item[\refstepcounter{subproject}(\thesubproject)]
}{\end{description}}


\begin{document}
\title{Project 3}   % self-explanatory
\author{Eivind Støland, Anders P. Åsbø}               % self-explanatory
\date{\today}                             % self-explanatory
\noaffiliation                            % ignore this

\maketitle                                % creates the title, author, date


\tableofcontents

\section{Introduction} \label{sec:I}

\section{Formalism} \label{sec:II}

\subsection{Two methods for numerical integration}
To solve our equations of motion we require methods for numerical integration. To derive our first method, we consider the generic function \(f\) that depends on a variable \(t\) such that
\begin{align*}
	\frac{d}{dt}f(t) = g(t, f(t)). \numberthis \label{eq:fofg}
\end{align*}
Given an arbitrary point \(f(t_{0})\), we wish to approximate the point \(f(t_{1})\). Thus we can integrate each side of \eqref{eq:fofg}, such that
\begin{align*}
	\int_{t_{0}}^{t_{1}} \frac{d}{dt} f(t) dt = \int_{t_{0}}^{t_{1}} g(t, f(t)) dt.
\end{align*}
Applying the fundemental theorem of calculus, we get that
\begin{align*}
	f(t_{1}) - f(t_{0}) = \int_{t_{0}}^{t_{1}} g(t, f(t)) dt, \\
	f(t_{1}) = f(t_{0}) + \int_{t_{0}}^{t_{1}} g(t, f(t)) dt. \numberthis \label{eq:foft1}
\end{align*}
To complete the approximation, we define a step-length \(\Delta t = t_{1}-t_{0}\), and approximate the area under the curve of \(g(t, f(t))\) between \(g(t_{0}, f(t_{0})\) and \(g(t_{1}, f(t_{1}))\) as the area of a rectangle whith height \(g(t_{0}, f(t_{0}))\). Inserting the rectangle approximation into \eqref{eq:foft1} yields
\begin{align*}
	f(t_{0} + \Delta t) \approx f(t_{0}) + \Delta t g(t_{0}, f(t_{0})).
\end{align*}

As we neglect all terms of second order or higher in this approximation we have that the error goes as $\mathcal{O}(\Delta t^2)$. 
If we want to approximate a value \(f(t_{k+1})\), we can simply start with a known value at a \(t_{k} < t_{k+1}\) and take a step with our approximation such that
\begin{align*}
	f(t_{k+1}) \approx f(t_{k}) + \Delta t g(t_{k}, f(t_{k})).
\end{align*}
Finally we can simplify the notation by setting \(f_{k+1} = f(t_{k})\) resulting in
\begin{align*}
	f_{k+1} = f_{k} + \Delta t g(t_{k}, f_{k}). \numberthis \label{eq:forwardEuler}
\end{align*}
This method of numerical integration is known as Euler's method, henceforth referred to as the forward Euler method.

Since we are approximating the integral between each pair of \(g(t, f_{k})\) and \(g(t, f_{k+1})\)  as a single rectangle with width \(\Delta t\), our approximation will be more accurate for smaller values of \(\Delta t\). Thus to approximate the curve of the function \(f\), we create a set of \(f_{k}\) values for a given \(f_{0}\) and \(\Delta t\) by repeatedly taking steps using the forward Euler method.

Many physical problems can be represented by a second order differential equation:

\begin{align*}
\frac{d^2}{dt^2} \vec{x}(t) &= \vec{a}(t,\vec{x}(t)) \, , \numberthis \label{eq:sodiff}
\end{align*}

where $\vec{x}(t)$ is the function we want to find and $\vec{a}(t,\vec{x}(t))$ is a function dependent on $\vec{x}(t)$. As the parts of this equation are vectors, this is actually a set of $D$ differential equations, where $D$ is the length of the vectors. This differential equation can be split into $2D$ first order differential equations:

\begin{align*}
\frac{d}{dt} \vec{v}(t) &= \vec{a}(t,\vec{x}(t))  \\
\frac{d}{dt} \vec{x}(t) &= \vec{v}(t) \, , \numberthis \label{eq:sodiff_split}
\end{align*}

When split into first order differential equations like this we can easily solve this system using methods such as the forward Euler method given a set of initial conditions. 

%In this kind of system we can make a small adaptation to the forward Euler method. The method with this small change is called the Euler-Cromer method (using the same discretization that was described earlier): 

%\begin{align*}
%\vec{v}_{k+1} &= \vec{v}_k + \Delta t  \vec{a}(t_k, \vec{x}_k) \\
%\vec{x}_{k+1} &= \vec{x}_k + \Delta t \vec{v}_{k+1} \numberthis \label{eq:EulerCromer}
%\end{align*}  

%Instead of using $\vec{v}_k$ to calculate $\vec{x}_{k+1}$ we use the next step $\vec{v}_{k+1}$. This improves the accuracy of the numerical solution. 

Another method used to solve the system of equations in \eqref{eq:sodiff_split} is the Velocity Verlet algorithm. We will now derive this algorithm. First we Taylor expand $\vec{x}(t + \Delta t)$:

\begin{align*}
\vec{x}(t + \Delta t) &= \vec{x}(t) + \Delta t \vec{v}(t) + \frac{\Delta t^2}{2} \vec{a}(t) + \mathcal{O}(\Delta t^3) \numberthis \label{eq:so_taylorx}
\end{align*}

Using the discretization described earlier, along with defining $\vec{x}(t_k) = \vec{x}_k$ and $\vec{v}(t_k) = \vec{v}_k$ we can rewrite this equation: 

\begin{align*}
\vec{x}_{k + 1} &\approx \vec{x}_k + \Delta t \vec{v}_k + \frac{\Delta t^2}{2} \vec{a}(t_k,\vec{x}_k) \numberthis \label{eq:so_taylorx_disc}
\end{align*}

Similarly we can also Taylor expand $\vec{v}(t+\Delta t)$:

\begin{align*}
\vec{v}(t+\Delta t) &= \vec{v}(t) + \Delta t \vec{a}(t) + \frac{\Delta t^2}{2} \frac{d}{dt} \vec{a}(t) + \mathcal{O}(\Delta t^3) \numberthis \label{eq:so_taylorv}
\end{align*}

We do not know what $\frac{d}{dt} \vec{a}(t)$ is, but we can approximate it:

\begin{align*}
\frac{d}{dt}\vec{a}(t) &= \frac{\vec{a}(t+\Delta t) - \vec{a}(t)}{\Delta t} + \mathcal{O}(\Delta t^2) \\
\Delta t \frac{d}{dt} \vec{a}(t) &= \vec{a}(t+ \Delta t ) - \vec{a}(t) + \mathcal{O}(\Delta t^3) 
\end{align*}

Inserting this into \eqref{eq:so_taylorv} gives:

\begin{align*}
\vec{v}(t+\Delta t) &= \vec{v}(t) + \Delta t \vec{a}(t) + \frac{\Delta t}{2} (\vec{a}(t+ \Delta t ) - \vec{a}(t)) + \mathcal{O}(\Delta t^3) \\
&= \vec{v}(t) + \frac{\Delta t}{2} (\vec{a}(t+ \Delta t ) + \vec{a}(t)) +  \mathcal{O}(\Delta t^3) 
\end{align*}

Discretizing this gives:

\begin{align*}
\vec{v}_{k+1} &\approx \vec{v}_k + \frac{\Delta t}{2} \bigg( \vec{a}(t_{k+1}, \vec{x}_{k+1}) + \vec{a}(t_k, \vec{x}_k) \bigg)
\end{align*}

Combining this with \eqref{eq:so_taylorx_disc} gives us the Velocity Verlet algorithm:

\begin{align*}
\vec{x}_{k+1} &= \vec{x}_k + \Delta t \vec{v}_k + \frac{1}{2} \Delta t^2 \vec{a}(t_k,\vec{x}_k) \\
\vec{v}_{k+1} &= \vec{v}_k + \frac{1}{2}\Delta t \bigg( \vec{a}(t_{k+1},x_{k+1}) + \vec{a}(t_k, \vec{x}_k) \bigg) \, . \numberthis \label{eq:VelocityVerlet}
\end{align*}

In this algorithm we first move the position one step, and then use this when calculating $\vec{v}$ in the next step. This algorithm has two advantages over the forward Euler method. Firstly it is approximately symplectic, meaning that if it is used to solve a set of equations given by Newton's second law there is little to no energy drift. Secondly the error of the approximation goes as $\mathcal{O}(\Delta t^3)$ compared to $\mathcal{O}(\Delta t^2)$ for the forward Euler method. 

\subsection{A generalized gravitational force}
For any two bodies \(a\) and \(b\), the gravitational force acting on body \(a\) from body \(b\) is
\begin{align*}
	\vec{F}_{a} = -G\frac{m_{a}m_{b}}{|\vec{r}_{a}-\vec{r}_{b}|^{3}}\left(\vec{r}_{a}-\vec{r}_{b}\right), \numberthis \label{eq:grav} \\
\end{align*}
where \(m_{a}\) and \(m_{b}\) are the masses of \(a\) and \(b\) respectivly, \(\vec{r}_{a}\) and \(\vec{r}_{b}\) are the position vectors of \(a\) and \(b\) respectivly, and \(G\) is the gravitational constant. The potential energy in such a gravitational field is:

\begin{align*}
U &= - G \frac{m_a m_b}{|\vec{r}_a - \vec{r}_b|} \numberthis \label{eq:pot_en}
\end{align*}

For a circular motion of body $a$ around $b$ this should remain constant as the distance between the objects is always the same. The total energy of any closed system is also conserved, and this means that the kinetic energy also has to be conserved, as the total energy is the sum of the kinetic and potential energy. In an elliptical motion however, only the total energy is conserved, and we will see oscillations in the kinetic and potential energy.

If we consider a body in a \(n\)-body system where the only interaction is gravitational, the net force on any body \(i\) becomes the sum of all the forces on body \(i\) from every other body in the system. Using \eqref{eq:grav} and summing over all bodies \(j\), where \(j\neq i\), we get
\begin{align*}
	\vec{F}_{i} = -Gm_{i}\sum_{j\neq i}m_{j}\frac{\vec{r}_{i}-\vec{r}_{j}}{|\vec{r}_{i}-\vec{r}_{j}|^{3}}. \numberthis \label{eq:gengrav}
\end{align*}

We then find the acceleration of body \(i\) at time \(t\) by dividing the net force by \(m_{a}\) resulting in
\begin{align*}
	\vec{a}_{i}(t) = \frac{\vec{F}_{i}(t)}{m_{i}} = -G\sum_{j\neq i}m_{j}\frac{\vec{r}_{i}(t)-\vec{r}_{j}(t)}{|\vec{r}_{i}(t)-\vec{r}_{j}(t)|^{3}},
\end{align*}
which can be written as the differential equation
\begin{align*}
 	\frac{d\vec{v}_{i}(t)}{dt} = -G\sum_{j\neq i}m_{j}\frac{\vec{r}_{i}(t)-\vec{r}_{j}(t)}{|\vec{r}_{i}(t)-\vec{r}_{j}(t)|^{3}}. \numberthis \label{eq:gendv}
\end{align*}
In addition we have the differential equation
\begin{align*}
	\frac{d\vec{r}_{i}(t)}{dt} = \vec{v}(t) \numberthis \label{eq:gendr}.
\end{align*}

Solving \eqref{eq:gendv} and \eqref{eq:gendr} for every body \(i=1, ..., n\), allows us to find the internal motion of a given n-body system with only gravitational interaction. In this system we can also define total potential energy:

\begin{align*}
U_\text{tot} &= \sum\limits_i - G m_i \sum\limits_{j\neq i} \frac{m_j}{|\vec{r}_i - \vec{r}_j|} \, , \numberthis \label{eq:tot_pot_en}
\end{align*}

and the total kinetic energy:

\begin{align*}
K_\text{tot} &= \sum\limits_i \frac{1}{2}m_i \vec{v}_i^2 \numberthis \label{eq:tot_kin_en}
\end{align*}

The sum of the total kinetic and potential energy of the system should be constant. This can be used to test the algorithms.

We will also be experimenting with a slightly different form of the force in \eqref{eq:grav}:

\begin{align*}
\vec{F}_a = - G \frac{m_a m_b}{|\vec{r}_a - \vec{r}_b|^{\beta + 1} } ( \vec{r}_a - \vec{r}_b) \, , \numberthis \label{eq:beta_grav}
\end{align*}

where $\beta \in [2,3]$ is a real constant. Choosing $\beta = 2$ corresponds to the normal gravitational force, and choosing a $\beta$ larger than this means that the force will be stronger for objects that are closer to each other and weaker for those that are far from each other. In a $n$-body system such as in \eqref{eq:gengrav} we have that the total force an object experiences is:

\begin{align*}
\vec{F}_{i} = -Gm_{i}\sum_{j\neq i}m_{j}\frac{\vec{r}_{i}-\vec{r}_{j}}{|\vec{r}_{i}-\vec{r}_{j}|^{\beta + 1}}. \numberthis \label{eq:beta_gengrav}
\end{align*}

We can also define the total potential energy in this case:

\begin{align*}
U_\text{tot} = U_\text{tot} &= \sum\limits_i - G m_i \sum\limits_{j\neq i} \frac{m_j}{|\vec{r}_i - \vec{r}_j|^{\beta-1}} . \numberthis \label{eq:beta_tot_pot_en}
\end{align*}

The total kinetic energy remains the same in this case.

\subsection{Conservation of angular momentum} \label{sec:II:c}

Kepler's second law states that the position vector between a planet and the Sun sweeps out a constant area for a given interval of time, no matter the starting position of the planet in its orbit. Mathematically this can be formulated as follows:

\begin{align*}
\frac{dA}{dt} &= \frac{r^2}{2} \frac{d\theta}{dt} \, , \numberthis \label{eq:kepler_second}
\end{align*}   

where $A$ is the area swept by the position vector, $r$ is the length of the position vector and $\theta$ is the angle determining the direction of the position vector. It is implicit here that we are looking at the 2D plane that the planet orbits the Sun in as the $xy$-plane, as this simplifies the equation significantly. 

The angular momentum is given by:

\begin{align*}
\ell &= |\vec{r} \cross \vec{p}| \, ,\numberthis \label{eq:ang_mom}
\end{align*}

where $\vec{r}$ is the position vector, and $\vec{p} = m \vec{v}$ is the momentum vector with $\vec{v}$ being the velocity vector and $m$ being the mass. Now we can make some assumptions. Assuming that the position vector rotates in the $xy$-plane the only contribution to the cross product comes from the tangential component of the velocity $v_\theta$. If we assume the tangential velocity to be in positive $\theta$-direction (we can always transform the chosen plane so that this is the case) we get:

\begin{align*}
\ell &= mrv_\theta \numberthis \label{eq:2D_ang_mom}
\end{align*}

Using that $\vec{v} = \frac{d}{dt} \vec{r}$ we can write:

\begin{align*}
v_\theta &= r \frac{d\theta}{dt}
\end{align*}

We can insert this along with \eqref{eq:2D_ang_mom} into \eqref{eq:kepler_second}:

\begin{align*}
\frac{dA}{dt} &= \frac{r^2}{2} \frac{d\theta}{dt} \\
\frac{dA}{dt} &= \frac{r}{2} v_\theta \\
\frac{dA}{dt} &= \frac{1}{2} \frac{\ell}{m} 
\end{align*}

Since we already know that the left-hand side of this equation is constant this directly implies that the size of the angular momentum is a conserved quantity as we also assume the mass to be constant. 

For a system of $n$-bodies such as in the previous section we can define the total angular momentum of a system as:

\begin{align*}
\vec{L}_\text{tot} &= \sum\limits_i \vec{r}_i \cross m\vec{v}_i \numberthis \label{eq:tot_ang_mom}
\end{align*}

For a closed system the norm of this quantity should be conserved.

\subsection{Escape velocity of object in gravitational field} \label{sec:II:d}

An object has a velocity large enough to escape a gravitational field when the total energy of the object is larger than zero. In other words we need the velocity $v$ to fulfill the following requirement:

\begin{align*}
K + U &\geq 0 \\
\frac{1}{2}mv^2 - \frac{GMm}{r} &\geq 0 \\
v &\geq \sqrt{\frac{2GM}{r}} \, ,
\end{align*}

where $K$ is the kinetic energy, $U$ the potential energy, $G$ the gravitational constant, $m$ the mass of the object, $M$ the mass of the object causing the gravitational field, $r$ the distance between them, and $v$ the size of the velocity of the object relative to the object causing the field. The escape velocity $v_e$ is the lowest velocity that allows escape in this way, and is thus given by the formula:

\begin{align*}
v_e &= \sqrt{\frac{2GM}{r}} \numberthis \label{eq:esc_vel}
\end{align*} 

\subsection{Perihelion precession of Mercury} \label{sec:II:e}

The observed precession of Mercury's perihelion is about 43'' per century when all contributions from classical effects are subtracted. By adding a relativistic correction term we can verify that we obtain the same result. The gravitational force between Mercury and the Sun with the relativistic correction term is as follows:

\begin{align*}
F_G &= \frac{GM_\text{Mercury} M_\text{Sun}}{r^2} \bigg[ 1 + \frac{3l^2}{r^2 c^2}\bigg] \, , \numberthis \label{eq:grav_rel} 
\end{align*}

where $M_\text{Mercury}$ is the mass of Mercury, $M_\text{Sun}$ the mass of the Sun, $r$ the distance between Mercury and the Sun, $c$ the speed of light, and $l$ the size of the angular momentum per unit mass. 

\subsection{Center of mass} \label{sec:II:f}

In an $n$-body system, where body $i$ has mass $m_i$, position $\vec{r}_i$, and velocity $\vec{v}_i$ we have that the position of the center of mass $\vec{R}$ is:

\begin{align*}
\vec{R} &= \frac{1}{M}\sum\limits_i m_i \vec{r}_i \, , \numberthis \label{eq:cofm_pos}
\end{align*}

where:

\begin{align*}
M &= \sum\limits_i m_i \numberthis \label{eq:tot_mass}
\end{align*}

We can also find the velocity of the center of mass $\vec{V}$:

\begin{align*}
\vec{V} &= \frac{1}{M} \sum\limits_i m_i \vec{v}_i \numberthis \label{eq:cofm_vel}
\end{align*}

We can always transform to a reference frame where the origin is placed at the center of mass, and all the velocities of the objects making up the system are relative to the velocity of the center of mass. If there are no external forces the center of mass reference frame does not change, and is thus ideal when simulating systems such as the ones we are modelling. To transform our reference frame into the center of mass reference frame it is enough to subtract the center of mass position from the positions of all the bodies, and the center of mass velocity from the velocity of all the bodies:

\begin{align*}
\vec{r}_i' &= \vec{r}_i - \vec{R} \\
\vec{v}_i' &= \vec{v}_i - \vec{V} \, , \numberthis \label{eq:cofm_transform}
\end{align*}

where $\vec{r}_i'$ is the position of body $i$ in the center of mass reference frame, and $\vec{v}_i$ the velocity of body $i$ in the center of mass reference frame.

\section{Method} \label{sec:III}

\subsection{Implementation} \label{sec:III:a}

In this section we will discuss the layout of the code and what each part does. As there is a lot of code we will only be including some snippets of code directly, and in some instances we will make references to functions and variables not shown in the code snippets. In these cases the reader should look to the source code if he or she wishes to know more. Links to the source code can be found in appendix \hyperref[A]{A}. The units chosen can be found Table \hyperref[table:III:a:i]{1}.

\begin{table}[h!] \label{table:III:a:i}
\caption{Table containing the units used in the programs. See section \hyperref[sec:III:a]{III.A} for more details on these programs.}
\begin{tabular}{|c|c|}
\hline
 & Unit \\
\hline
Length & AU \\
Time & Year \\
Mass & Mass of the Sun \\
\hline
\end{tabular}
\end{table}

We have written a set of object oriented programs in C++ that together simulate a set of point objects with a gravitational interaction. We use these programs to simulate the solar systems. In order to better interface with these programs we have automated running them using a python script, which we will get back to once we have explained the general layout and implementation of the algorithms.

The most basic part of the program is the \verb+CelestialBody+ class. The \verb+CelestialBody+ object is used to store the position, velocity, mass, and force an object is experiencing. No calculation in general is done in this class. See appendix \hyperref[A.5]{A.5} for the full code. The vectors (position, velocity and force) are stored as Armadillo \citep{Armadillo} vectors, as these have built-in functionality for the mathematical operations we need.

The level above the \verb+CelestialBody+ class is the \verb+SolarSystem+ class. This class creates \verb+CelestialBody+ objects and stores them in the standard library vector object \verb+m_bodies+. In this class we also calculate the forces that each object feels with one of two functions. The first one, called \verb+calculateForcesAndEnergy()+, is as follows:

\onecolumngrid
\begin{cpp}
void SolarSystem::calculateForcesAndEnergy() {
  // Clear variables
  m_kinetic_energy = 0;
  m_potential_energy = 0;
  m_angular_momentum = arma::zeros(3);
  for (CelestialBody &body: m_bodies) {
    body.force.zeros();
  }

  // Iterate over every body (body1)
  for (int i = 0; i<numberOfBodies();++i){
    CelestialBody &body1 = m_bodies[i];
    // Second iteration over every body after body1 (body2)
    for (int j = i+1; j<numberOfBodies();++j) {
      CelestialBody &body2 = m_bodies[j];

      // Distance vector
      arma::vec dr_vec = body2.position - body1.position;

      // Length of distance vector
      double dr = arma::norm(dr_vec);

      // Potential energy between body1 and body2
      double potential_energy = m_G*body1.mass*body2.mass/std::pow(dr,m_beta-1);

      // Force vector between the bodies (sign adjusted when adding to the bodies)
      arma::vec gravforce = dr_vec*potential_energy/(dr*dr);
      body1.force += gravforce;
      body2.force -= gravforce;

      // Adding potential energy to total
      m_potential_energy -= potential_energy;
    }

    // Adding kinetic energy of body1 to total
    double v = arma::norm(body1.velocity);
    m_kinetic_energy += 0.5*body1.mass*v*v;

    // Adding angular momentum of body1 to total angular momentum
    m_angular_momentum += arma::cross(body1.position,body1.mass*body1.velocity);
  }
}
\end{cpp}
\twocolumngrid

The function uses \eqref{eq:beta_gengrav} to calculate the force an object experiences, \eqref{eq:beta_tot_pot_en} to calculate the total potential energy, \eqref{eq:tot_kin_en} to calculate total kinetic energy, and \eqref{eq:tot_ang_mom} to calculate the total angular momentum. All are stored in internal variables in the class, and can be retrieved using methods built into the class. The parameter $\beta$ is decided upon instantiating the class, which we will get back to. 

The second function is \verb+calculateForcesWithRelativisticCorrection()+:

\onecolumngrid
\begin{cpp}
void SolarSystem::calculateForcesWithRelativisticCorrection() {
  // Clear variables
  for (CelestialBody &body: m_bodies) {
    body.force.zeros();
  }

  // Iterate over every body (body1)
  for (int i = 0; i<numberOfBodies();++i){
    CelestialBody &body1 = m_bodies[i];

    // Calculate angular momentum vector, size and squared size
    arma::vec l_vec = arma::cross(body1.position,body1.velocity);
    double l = arma::norm(l_vec);
    double l2 = l*l;

    // Iterate over every body after body1 (body2)
    for (int j = i+1; j<numberOfBodies();++j) {
      CelestialBody &body2 = m_bodies[j];

      // Distance vector
      arma::vec dr_vec = body2.position - body1.position;

      // Length of distance vector
      double dr = arma::norm(dr_vec);
      double dr2 = dr*dr;

      // Potential energy between body1 and body2
      double potential_energy = m_G*body1.mass*body2.mass/dr;

      // Calculate force vector with relativistic correction factor (sign adjusted when adding to the bodies)
      arma::vec gravforce = dr_vec*(potential_energy/dr2) * (1 + m_rel_constant*l2/dr2 );
      body1.force += gravforce;
      body2.force -= gravforce;
    }
  }
}
\end{cpp}
\twocolumngrid

This one calculates the forces on each object using \eqref{eq:grav_rel}. As we have no expression for what the potential energy is in this case we have chosen to omit all calculation of potential energy. We also have no expectation of how angular momentum and kinetic energy will behave, so we have omitted calculation of these quantities aswell. In other words, when calling these functions these quantities remain as they are instantiated, as zero or the zero-vector in the case of the angular momentum.

There are four ways to instantiate the \verb+SolarSystem+ class. The first constructor takes no arguments. In this case the internal variables for potential and kinetic energy are set to 0, the angular momentum set to the zero-vector, and \verb+m_beta+ (the internal variable for $\beta$ in \eqref{eq:beta_grav}) is set to 2. The second constructor takes one double as an argument. \verb+m_beta+ is set to be equal to this double, and otherwise this functions similarly to the first constructor. When instantiated in both these ways the \verb+CelestialBody+ objects that make up the system must be instantiated manually using the \verb+createCelestialBody()+ method. This method takes two Armadillo \citep{Armadillo} three-component vectors and a double as input (in that order). The first vector should contain the initial position of the object instantiated, the second should contain the velocity, and the double should be the mass of the object. The base units of these quantities should be as in Table \hyperref[table:III:a:i]{1}. 

The third way to instantiate the class is with a string as an argument. The string is taken to be the path leading to a file with initial conditions for the system. Each line in such a file should contain first the three cartesian coordinates ($x$,$y$,$z$) of an object, then the three components of the velocity ($v_x$,$v_y$,$v_z$), and then  lastly the mass of the object, all with a single whitespace between them. The file can be of arbitrary length as long as it is formatted correctly. This constructor first calls the first constructor, then instantiates all the objects in the file using the \verb+createCelestialBody()+ function, and then calls the \verb+moveToCOFMFrame()+ function which we will cover shortly. The fourth way of instantiating class works very similarly to the third one, in that it takes the path to a file of initial conditions as an argument, but now it also takes a double, which is taken to be \verb+m_beta+. It functions in exactly the same way as the third one, except that instead of calling the first constructor, it calls the second one so that \verb+m_beta+ is stored correctly.

The class also contains the \verb+moveToCOFMFrame()+ function. As the name says, this transforms the coordinates and velocities of all the objects of the system so that the origin is the center of mass in the simulation. The function uses \eqref{eq:cofm_pos}, \eqref{eq:cofm_vel} and \eqref{eq:cofm_transform} to perform the transformation.

The three last functions of the class that we want to cover are \verb+initiateDataFile()+, \verb+writeToFile()+ and \verb+writeEnergyToFile()+. These are used together to write data generated during the simulation to files. The \verb+initiateDataFile()+ is overloaded so that it takes either one or two strings as arguments. If one is given, it is taken to be the path leading to the file that the positions of all the objects should be written to. If two are given, the first one is taken to be the path leading to the file that the positions of the objects should be written to, and the second is taken to be the path leading to the file that potential energy, kinetic energy and angular momentum should be written to. 

The \verb+writeToFile()+ function takes no arguments, but any time it is called, the current positions of all the objects are written on a new line in the file. Each line contains first the $x$, $y$ and $z$ coordinates of the first object (in that order), then the same coordinates for the second object, and so on until all the positions have been written to the file specified with \verb+initiateDataFile()+. All the coordinates are separated by a single whitespace. If \verb+initiateDataFile()+ has not been ran, this function will not work. 

The \verb+writeEnergyToFile()+ function takes no arguments, but any time it is called, the current kinetic energy, potential energy, and the components of the angular momentum are written to a new line (in that order, separated by a single whitespace) in the datafile specified with \verb+initiateDataFile()+. If \verb+initiateDataFile()+ has not been ran, or if it has only been ran with one argument this function will not work.

\section{Results} \label{sec:IV}

\section{Discussion} \label{sec:V}

\section{Conclusion} \label{sec:VI}
\onecolumngrid
\bibliography{kilder.bib}{}
\newpage
\twocolumngrid

\appendix
\section{Source code} \label{A}
All code for this report was written in C++ and Python 3.8, and the complete set of files can be found at
\url{https://github.com/eivinsto/FYS3150_Project2.git}.

\cprotect\subsection{\verb+project.py+} \label{A.1}
Main script for running project, plotting and data analysis.

\url{https://github.com/eivinsto/FYS3150_Project_3/blob/main/project.py}

\cprotect\subsection{\verb+main.cpp+} \label{A.2}
Main cpp file for running algorithms.

\url{https://github.com/eivinsto/FYS3150_Project_3/blob/main/src/main.cpp}

\cprotect\subsection{\verb+solar_integrator+} \label{A.3}
Source and header file containing class for integrating a velocity and position for a system of bodies.

Source file \verb+solar_integrator.cpp+:
\url{https://github.com/eivinsto/FYS3150_Project_3/blob/main/src/solar_integrator.cpp}

Header file \verb+solar_integrator.hpp+:
\url{https://github.com/eivinsto/FYS3150_Project_3/blob/main/src/solar_integrator.hpp}

\cprotect\subsection{\verb+solar_system+} \label{A.4}
Source and header file containing class for creating system of bodies, and calculating gravitational force between them, as well as kinetic and gravitational-potential energy of system.

Source file \verb+solar_system.cpp+:
\url{https://github.com/eivinsto/FYS3150_Project_3/blob/main/src/solar_system.cpp}

Header file \verb+solar_system.hpp+:
\url{https://github.com/eivinsto/FYS3150_Project_3/blob/main/src/solar_system.hpp}

\cprotect\subsection{\verb+celestial_body+} \label{A.5}
Source and header file containing class defining gravitational bodies.

Source file \verb+celestial_body.cpp+:
\url{https://github.com/eivinsto/FYS3150_Project_3/blob/main/src/celestial_body.cpp}

Header file \verb+celestial_body.hpp+:
\url{https://github.com/eivinsto/FYS3150_Project_3/blob/main/src/celestial_body.hpp}

\cprotect\subsection{\verb+test_main.cpp+} \label{A.6}
File running unit-tests using CATCH2 framework.

\url{https://github.com/eivinsto/FYS3150_Project_3/blob/main/src/test_main.cpp}

\cprotect\subsection{\verb+test_functions.cpp+} \label{A.7}
File containing the unit-tests for the system.

\url{https://github.com/eivinsto/FYS3150_Project_3/blob/master/src/test_functions.cpp}

\newpage
\section{Selected results} \label{B}
Here is a folder of selected results from running our code.

\url{https://github.com/eivinsto/FYS3150_Project_3/tree/master/data}

\newpage
\section{System specifications} \label{C}
All results included in this report were achieved by running the implementation on the following system:
\begin{itemize}
	\item CPU: AMD Ryzen \(9\) \(3900\)X
	\item RAM: \(2\times\SI{8}{\giga\byte}\) Corsair Vengeance LPX DDR\(4\) \(\SI{3200}{\mega\hertz}\)
\end{itemize}

\end{document}